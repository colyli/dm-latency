Index: linux-2.6.32-220.23.2.el5/drivers/md/dm.h
===================================================================
--- linux-2.6.32-220.23.2.el5.orig/drivers/md/dm.h
+++ linux-2.6.32-220.23.2.el5/drivers/md/dm.h
@@ -30,6 +30,86 @@
 #define DM_TYPE_REQUEST_BASED	2
 
 /*
+ * Work processed by per-device workqueue.
+ */
+struct mapped_device {
+	uint64_t features;	/* 3rd party driver must initialize to zero */
+	struct rw_semaphore io_lock;
+	struct mutex suspend_lock;
+	rwlock_t map_lock;
+	atomic_t holders;
+	atomic_t open_count;
+
+	unsigned long flags;
+
+	struct request_queue *queue;
+	unsigned type;
+	/* Protect queue and type against concurrent access. */
+	struct mutex type_lock;
+
+	struct target_type *immutable_target_type;
+
+	struct gendisk *disk;
+	char name[16];
+
+	void *interface_ptr;
+
+	/*
+	 * A list of ios that arrived while we were suspended.
+	 */
+	atomic_t pending[2];
+	wait_queue_head_t wait;
+	struct work_struct work;
+	struct bio_list deferred;
+	spinlock_t deferred_lock;
+
+	/*
+	 * Processing queue (flush)
+	 */
+	struct workqueue_struct *wq;
+
+	/*
+	 * The current mapping.
+	 */
+	struct dm_table *map;
+
+	/*
+	 * io objects are allocated from here.
+	 */
+	mempool_t *io_pool;
+	mempool_t *tio_pool;
+
+	struct bio_set *bs;
+
+	/*
+	 * Event handling.
+	 */
+	atomic_t event_nr;
+	wait_queue_head_t eventq;
+	atomic_t uevent_seq;
+	struct list_head uevent_list;
+	spinlock_t uevent_lock; /* Protect access to uevent_list */
+
+	/*
+	 * freeze/thaw support require holding onto a super block
+	 */
+	struct super_block *frozen_sb;
+	struct block_device *bdev;
+
+	/* forced geometry settings */
+	struct hd_geometry geometry;
+
+	/* For saving the address of __make_request for request based dm */
+	make_request_fn *saved_make_request_fn;
+
+	/* sysfs handle */
+	struct kobject kobj;
+
+	/* zero-length flush that will be cloned and submitted to targets */
+	struct bio flush_bio;
+};
+
+/*
  * List of devices that a metadevice uses and should open/close.
  */
 struct dm_dev_internal {
Index: linux-2.6.32-220.23.2.el5/drivers/md/dm.c
===================================================================
--- linux-2.6.32-220.23.2.el5.orig/drivers/md/dm.c
+++ linux-2.6.32-220.23.2.el5/drivers/md/dm.c
@@ -110,87 +110,7 @@ EXPORT_SYMBOL_GPL(dm_get_rq_mapinfo);
 #define DMF_DELETING 4
 #define DMF_NOFLUSH_SUSPENDING 5
 #define DMF_MERGE_IS_OPTIONAL 6
-
-/*
- * Work processed by per-device workqueue.
- */
-struct mapped_device {
-	uint64_t features;	/* 3rd party driver must initialize to zero */
-	struct rw_semaphore io_lock;
-	struct mutex suspend_lock;
-	rwlock_t map_lock;
-	atomic_t holders;
-	atomic_t open_count;
-
-	unsigned long flags;
-
-	struct request_queue *queue;
-	unsigned type;
-	/* Protect queue and type against concurrent access. */
-	struct mutex type_lock;
-
-	struct target_type *immutable_target_type;
-
-	struct gendisk *disk;
-	char name[16];
-
-	void *interface_ptr;
-
-	/*
-	 * A list of ios that arrived while we were suspended.
-	 */
-	atomic_t pending[2];
-	wait_queue_head_t wait;
-	struct work_struct work;
-	struct bio_list deferred;
-	spinlock_t deferred_lock;
-
-	/*
-	 * Processing queue (flush)
-	 */
-	struct workqueue_struct *wq;
-
-	/*
-	 * The current mapping.
-	 */
-	struct dm_table *map;
-
-	/*
-	 * io objects are allocated from here.
-	 */
-	mempool_t *io_pool;
-	mempool_t *tio_pool;
-
-	struct bio_set *bs;
-
-	/*
-	 * Event handling.
-	 */
-	atomic_t event_nr;
-	wait_queue_head_t eventq;
-	atomic_t uevent_seq;
-	struct list_head uevent_list;
-	spinlock_t uevent_lock; /* Protect access to uevent_list */
-
-	/*
-	 * freeze/thaw support require holding onto a super block
-	 */
-	struct super_block *frozen_sb;
-	struct block_device *bdev;
-
-	/* forced geometry settings */
-	struct hd_geometry geometry;
-
-	/* For saving the address of __make_request for request based dm */
-	make_request_fn *saved_make_request_fn;
-
-	/* sysfs handle */
-	struct kobject kobj;
-
-	/* zero-length flush that will be cloned and submitted to targets */
-	struct bio flush_bio;
-};
-
+s
 /*
  * For mempools pre-allocation at the table loading time.
  */

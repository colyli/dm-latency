Index: linux-2.6.32-279.14.1.el5/drivers/md/dm.c
===================================================================
--- linux-2.6.32-279.14.1.el5.orig/drivers/md/dm.c
+++ linux-2.6.32-279.14.1.el5/drivers/md/dm.c
@@ -20,6 +20,7 @@
 #include <linux/idr.h>
 #include <linux/hdreg.h>
 #include <linux/delay.h>
+#include <linux/clocksource.h>
 
 #include <trace/events/block.h>
 
@@ -49,6 +50,7 @@ struct dm_io {
 	struct bio *bio;
 	unsigned long start_time;
 	spinlock_t endio_lock;
+	unsigned long long start_time_usec;
 };
 
 /*
@@ -384,6 +386,42 @@ static int md_in_flight(struct mapped_de
 	       atomic_read(&md->pending[WRITE]);
 }
 
+static unsigned long long ns2usecs(cycle_t nsec)
+{
+	nsec += 500;
+	do_div(nsec, 1000);
+	return nsec;
+}
+
+static unsigned long long us2msecs(unsigned long long usec)
+{
+	usec += 500;
+	do_div(usec, 1000);
+	return usec;
+}
+
+static void update_latency_stats(struct mapped_device *md, struct dm_io *io)
+{
+	unsigned long long now, latency;
+	int idx;
+	now = (unsigned long long)ns2usecs(sched_clock());
+	latency = (unsigned long long)(now - io->start_time_usec);
+
+	if (latency < 1000) {
+		/* microseconds */
+		idx = latency/DM_LATENCY_STATS_US_GRAINSIZE;
+		if (idx > (DM_LATENCY_STATS_US_NR - 1))
+			idx = DM_LATENCY_STATS_US_NR - 1;
+		atomic_inc(&(md->latency_stats_us[idx]));
+	} else {
+		/* milliseconds */
+		idx = us2msecs(latency)/DM_LATENCY_STATS_MS_GRAINSIZE;
+		if (idx > (DM_LATENCY_STATS_MS_NR - 1))
+			idx = DM_LATENCY_STATS_MS_NR - 1;
+		atomic_inc(&(md->latency_stats_ms[idx]));
+	}
+}
+
 static void start_io_acct(struct dm_io *io)
 {
 	struct mapped_device *md = io->md;
@@ -391,6 +429,7 @@ static void start_io_acct(struct dm_io *
 	int rw = bio_data_dir(io->bio);
 
 	io->start_time = jiffies;
+	io->start_time_usec = (unsigned long long)ns2usecs(sched_clock());
 
 	cpu = part_stat_lock();
 	part_round_stats(cpu, &dm_disk(md)->part0);
@@ -411,6 +450,8 @@ static void end_io_acct(struct dm_io *io
 	part_stat_add(cpu, &dm_disk(md)->part0, ticks[rw], duration);
 	part_stat_unlock();
 
+	update_latency_stats(md, io);
+
 	/*
 	 * After this is decremented the bio must not be touched if it is
 	 * a flush.
@@ -1828,6 +1869,12 @@ static struct mapped_device *alloc_dev(i
 	md->flush_bio.bi_bdev = md->bdev;
 	md->flush_bio.bi_rw = WRITE_FLUSH;
 
+	/* initial latency stats buckets */
+	for (r = 0; r < DM_LATENCY_STATS_MS_NR; r++)
+		atomic_set(&(md->latency_stats_ms[r]), 0);
+	for (r = 0; r < DM_LATENCY_STATS_US_NR; r++)
+		atomic_set(&(md->latency_stats_us[r]), 0);
+
 	/* Populate the mapping, nobody knows we exist yet */
 	spin_lock(&_minor_lock);
 	old_md = idr_replace(&_minor_idr, md, minor);
Index: linux-2.6.32-279.14.1.el5/drivers/md/dm.h
===================================================================
--- linux-2.6.32-279.14.1.el5.orig/drivers/md/dm.h
+++ linux-2.6.32-279.14.1.el5/drivers/md/dm.h
@@ -29,6 +29,12 @@
 #define DM_TYPE_BIO_BASED	1
 #define DM_TYPE_REQUEST_BASED	2
 
+/* 200 milliseconds is max disk I/O latency which application may accept */
+#define DM_LATENCY_STATS_MS_NR		20
+#define DM_LATENCY_STATS_MS_GRAINSIZE	(200/DM_LATENCY_STATS_MS_NR)
+#define DM_LATENCY_STATS_US_NR		20
+#define DM_LATENCY_STATS_US_GRAINSIZE	(1000/DM_LATENCY_STATS_US_NR)
+
 /*
  * Work processed by per-device workqueue.
  */
@@ -107,6 +113,10 @@ struct mapped_device {
 
 	/* zero-length flush that will be cloned and submitted to targets */
 	struct bio flush_bio;
+
+	/* latency statistic buckets */
+	atomic_t latency_stats_ms[DM_LATENCY_STATS_MS_NR];
+	atomic_t latency_stats_us[DM_LATENCY_STATS_US_NR];
 };
 
 /*
